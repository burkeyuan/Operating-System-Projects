Firstly, define various parameters, structs, arrays and variables. The numbers of frames, pages, TLBs and page size are defined as four parameters. So we can change these parameters easily to adjust to different situations. Then define several structs. The Addr struct contains the physical address, page number, offset and value of a logical address and itself. The TLBs struct contains the page number, frame number and the latest used time of a part in TLB. The PageTables struct contains the frame number and the latest used time of a page. Afterwards, define arrays and variables. The Frame[] array denotes the page number contained in each frame. The time1 variable is used to record the global time. Other variablesâ€™ are obvious, such as Num_fault and Num_TLB.
Secondly, design several functions which are used in the main function. With init_TLB() and init_PageTable(), set all the members except use time in TLB and PageTable structs to -1. If the members of a part in TLB are 0, the part is available for use. If the latest use time of a page in PageTable is 0, the page has not been used. If the frame number of a page in PageTable is -1, the page has not been assigned a frame. The extract() functions calculates the page number and offset of a logical address by using and logical operation and moving bits. The getvalue() function can get the value of a reference from the physical memory according to the corresponding frame number and offset. The move() function copies data from BACKING_STORE.bin to the physical memory(the PhyMem[][] array). It is implemented by several built-in functions: fopen(), fseek(), fread() and  fclose(). The first one and last one are used to open and close BACKING_STORE.bin and the second one is used to move the pointer with a distance and then can read the 
correct data. In Page_Consult() function there are three different situations. If a page already has a frame number the function just updates the use time of the page. If a page has not been assigned a frame and there are more than one free frames, assign a frame to it by using first-fit algorithm and update various information such as use time and Num_PageFault. For example, if only frame0 to frame 4 are allocated, the next frame can be allocated is frame5. If a page has not assigned a frame and all the frames has been allocated, use LRU algorithm to find a suitable frame. By comparing the use time of each page and corresponding frame, the function can know which pair is the least recently used and then allocates the frame to the new page which needs a frame. Then update relevant information. In TLB_consult() function, there are two situations. If we can find the page number in TLB, we can use the corresponding frame number directly and increase Num_TLBHit by one. If not, we should first execute Page_Consult() to get the frame number for the page. Then  we need to find a part with first-fit algorithm or LRU algorithm. It is similar to that in Page_Consult() function. And we update the information in TLB.
Thirdly, we design the main function. By using fopen(), fclose() and fget() functions we get each address from addresses.txt in order and separately from each other. Then we can calculate the logical address we get. Afterwards, execute extract() and TLB_Consult() functions. At last, come to deal with next address. After all the operations are done, print all the information about the allocation. 
By now, the design and implementation of a virtual memory manager is completed.
