The project aims to sort a sequence of integers into a nondecreasing order by using the merge sort algorithm. In order to speed up the merge sort, multiple threads are used in every round of the sort. And the number of threads in round n is 2 to the power of n. I implement the project mainly by read_data() function, merge() function, while and for loops in the main function. Mutex and condition variable are also used.
By the read_data() function, the program can read the integers from indata.txt. Then it writes the integers into the array data[]. In order to handle the most difficult situation, the size of the array is initially set to 4096 to avoid segmentation fault. Also, after the reading process is completed, the number of the integers is stored in the global variable num.
The merge() function is a very important part of the project. As the number of the integers in the input file is 2 to the power of n and the barrier is used in this function, I make several changes based on the merge sort algorithm to fulfill the requirements. Firstly,  the function gets the values of two parameters, num_merge and left, by using a struct. The parameter num_merge means the number of integers the current function will merge. And the parameter left equals to the index of the first one of the group of integers. This approach may not be used in general cases, but it is efficient in the situation we assumed. Then the program can divide the group of integers into two parts and compare them based on the algorithm. After each step of comparison, the result(smaller integer) will first be stored in a new array cpy[]. Then after the comparison ends, the program copy the intermediate results in cpy[] to original data[]. The data[] is updated by the intermediate results in cpy[] in each round. Then we need to decrease the barrier by 1 and print the value of the barrier for test. And in order to prevent more than one thread accessing the barrier at the same time, I set a mutex and lock it before the operation of the barrier. If the mutex is unlocked, a thread can access the barrier. If he mutex is locked, other threads cannot access the barrier. And then if the barrier is over 0, it means that some other threads in current round have not completed the sort. Print “I am blocked”. So the current thread need to wait for them by using the pthread_cond_wait() function. If in a thread the barrier is found to be no bigger than 0 after the operation, it means all threads have completed their work and the current round can be ended. Print “I am unblocked”. So the program use pthread_cond_broadcast() function to wake up all waiting threads blocked on the condition variable. At last, the program unlocks the mutex. The test results of the barrier shows it is used correctly.
In the main function, we first initialize the mutex and condition, and also define all the needed variables and structs. Then when num_merge is no larger than num, the while loop will iterate. In the while loop, the program set the barrier to the number of threads in current round. The number of threads in first round is a half of num. Then the program creates all the threads one by one by using the for loop and pthread_create() function. After creating them, the main thread need to wait for all the threads to complete their work, instead of directly continue to next while loop. And the main thread does not participate in the comparisons. So the pthread_cond_wait() and pthread_cond_broadcast() functions should also be used here. The number of num_merge and num_thread will also be updated before a while loop ends. At last, the program prints the array data[] and we can check whether the result is correct as expected.
